<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pea Chat</title>

  <style>
    /* =====================================
       GLOBAL / RESET
    ======================================*/
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: "Inter", Arial, sans-serif;
      background: linear-gradient(135deg, #8b5cf6, #4f46e5);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 20px;
    }

    /* =====================================
       MAIN CHAT WRAPPER
    ======================================*/
    .chatbot {
      width: 100%;
      max-width: 780px;
      display: flex;
      flex-direction: column;
      border-radius: 20px;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 30px rgba(0,0,0,0.2);
      overflow: hidden;
      animation: fadeIn 0.6s ease both;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    /* =====================================
       HEADER
    ======================================*/
    .chat-header {
      padding: 1.3em;
      background: rgba(255,255,255,0.15);
      backdrop-filter: blur(6px);
      color: #0f0;
      text-align: center;
      font-weight: bold;
    }
    .chat-header h1 {
      font-size: 2em;
    }
    .meta { font-size: .9em; opacity: .9; }

    /* =====================================
       CHAT AREA
    ======================================*/
    .chat-messages {
      flex: 1;
      height: 500px;
      overflow-y: auto;
      padding: 1em;
      display: flex;
      flex-direction: column;
      gap: 0.8em;
    }

    .message {
      display: flex;
      align-items: flex-start;
      gap: 0.7em;
      animation: fadeIn 0.3s ease;
    }

    .user p {
      background-color: #7B58E5;
      color: #fff;
      padding: 0.6em 1em;
      border-radius: 18px 18px 0 18px;
      max-width: 85%;
      margin-left: auto;
      white-space: pre-wrap;
    }
    .aibot p {
      background-color: #ececec;
      color: #000;
      padding: 0.6em 1em;
      border-radius: 18px 18px 18px 0;
      max-width: 85%;
      white-space: pre-wrap;
    }

    /* Typing animation */
    .typing {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-top: 4px;
      background: #666;
      animation: blink 1s infinite ease-in-out;
    }
    @keyframes blink {
      0% { opacity: .2; }
      50% { opacity: 1; }
      100% { opacity: .2; }
    }

    /* =====================================
       MESSAGE FORM
    ======================================*/
    .chat-form {
      display: flex;
      padding: 1em;
      border-top: 1px solid #ddd;
      gap: 0.5em;
      background: #fafafa;
    }

    .chat-form textarea {
      flex: 1;
      padding: 0.8em 1em;
      border-radius: 18px;
      border: 1px solid #ddd;
      resize: none;
      font-size: 1em;
      min-height: 45px;
      max-height: 100px;
    }

    .chat-form button {
      background-color: #7B58E5;
      color: #fff;
      border: none;
      padding: 0 18px;
      border-radius: 18px;
      cursor: pointer;
      transition: 0.2s;
      font-size: 1.1em;
    }
    .chat-form button:hover {
      background-color: #633ad9;
    }
    /* =====================================
       LOGIN POPUP
    ======================================*/
    #login-popup {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    #login-card {
      background: white;
      padding: 25px;
      border-radius: 12px;
      width: 320px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.25);
      animation: fadeIn 0.5s;
    }

    #login-card input {
      width: 100%;
      margin-top: 10px;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #ccc;
    }
    #login-card button {
      width: 100%;
      padding: 12px;
      margin-top: 16px;
      background: #7B58E5;
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 1.05em;
      cursor: pointer;
    }
    #switch-mode {
      margin-top: 10px;
      color: #7B58E5;
      text-decoration: underline;
      cursor: pointer;
      font-size: 0.9em;
      text-align: center;
    }
  </style>
</head>
<body>
     <!-- LOGIN POPUP -->
    <div id="login-popup">
        <div id="login-card">
            <h3 id="login-title">Sign in</h3>

            <input id="login-email" type="email" placeholder="Email" />
            <input id="login-pass" type="password" placeholder="Password" />
            <input id="login-pass2" type="password" placeholder="Confirm password" style="display:none;" />

            <button id="login-btn">Login</button>
            <p id="login-error" style="color:red"></p>
            <div id="switch-mode">Don't have an account? Sign up</div>
        </div>
    </div>

    <main>
        <div class="chatbot">
            <div class="chat-header">
                <h1>Pea ðŸ«›</h1>
                <div class="meta" id="who">Not signed in</div>
                <button id="logout-btn">Logout</button>
            </div>

            <div id="chat-page">
                <div class="chat-messages" id="messages-container"></div>
                <form class="chat-form" id="message-form">
                    <textarea id="message-input" placeholder="Type a message..." rows="1"></textarea>
                    <button type="button" id="file-btn">ðŸ“Ž</button>
                    <input type="file" id="file-input" style="display:none;" multiple />
                    <button type="button" id="mic-btn">ðŸŽ¤</button>
                    <button type="submit">âž¤</button>
                </form>
            </div>
        </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    /* ============================== CONFIG ============================== */
    const API_BASE = "https://ej-0-training.hf.space";

    /* =================== DOM ELEMENTS =================== */
    const messagesContainer = document.getElementById('messages-container');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const micBtn = document.getElementById('mic-btn');
    const whoEl = document.getElementById('who');

    const loginPopup = document.getElementById('login-popup');
    const loginBtn = document.getElementById('login-btn');
    const loginEmail = document.getElementById('login-email');
    const loginPass = document.getElementById('login-pass');
    const loginPass2 = document.getElementById('login-pass2');
    const loginTitle = document.getElementById('login-title');
    const loginError = document.getElementById('login-error');
    const switchMode = document.getElementById('switch-mode');
    const logoutBtn = document.getElementById('logout-btn');
    const fileBtn = document.getElementById("file-btn");
    const fileInput = document.getElementById("file-input");

    let ACCESS_TOKEN = null;
    let REFRESH_TOKEN = null;
    let CURRENT_EMAIL = null;
    let isSignupMode = false;

    /* =================== MESSAGES =================== */
  /* =================== MESSAGES (UPDATED) =================== */
    // Returns the bubble element so we can update it during streaming
    function addMessage(text, role) {
        const wrapper = document.createElement("div");
        wrapper.className = "message " + role;
        
        const bubble = document.createElement("p");
        // Only parse if text exists, otherwise empty for streaming start
        bubble.innerHTML = text ? marked.parse(text) : '<span class="typing-cursor"></span>'; 
        
        wrapper.appendChild(bubble);
        messagesContainer.appendChild(wrapper);
        messagesContainer.scrollTo({ top: messagesContainer.scrollHeight, behavior: "smooth" });
        
        return bubble; // <--- RETURN THE DOM ELEMENT
    }

    function addMessagesFromHistory(messages) {
        messages.forEach(m => addMessage(m.content, m.role === "user" ? "user" : "aibot"));
    }
    /* =================== LOGOUT =================== */
    logoutBtn.onclick = async () => {
        try {
            await fetch(API_BASE + "/logout", {
    method: "POST",
    credentials: "include",
    headers: {
        "Authorization": "Bearer " + ACCESS_TOKEN,
        "Content-Type": "application/json"
    },
    body: JSON.stringify({ refresh_token: REFRESH_TOKEN })
});
        } catch (e) {
            console.warn("Logout failed:", e);
        }

        ACCESS_TOKEN = null;
        REFRESH_TOKEN = null;
        CURRENT_EMAIL = null;
        whoEl.innerText = "Not signed in";
        loginPopup.style.display = "flex";
      messagesContainer.innerHTML = "";
        addMessage("You have been logged out.", "aibot");
    };

    /* =================== SWITCH LOGIN / SIGNUP =================== */
    switchMode.onclick = () => {
        isSignupMode = !isSignupMode;
        if (isSignupMode) {
            loginTitle.innerText = "Sign up";
            loginBtn.innerText = "Create Account";
            switchMode.innerText = "Already have an account? Sign in";
            loginPass2.style.display = "block";
        } else {
            loginTitle.innerText = "Sign in";
            loginBtn.innerText = "Login";
            switchMode.innerText = "Don't have an account? Sign up";
            loginPass2.style.display = "none";
        }
        loginError.innerText = "";
    };

    /* =================== LOGIN / SIGNUP REQUEST =================== */
    loginBtn.onclick = async () => {
        loginError.innerText = "";
        const email = loginEmail.value.trim();
        const password = loginPass.value.trim();

        if (!email || !password) {
            loginError.innerText = "Fill all fields.";
            return;
        }

        if (isSignupMode) {
            const password2 = loginPass2.value.trim();
            if (password !== password2) {
                loginError.innerText = "Passwords do not match.";
                return;
            }

            // SIGNUP
            const res = await fetch(API_BASE + "/signup", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ email, password })
            });
            const data = await res.json();

            if (!data.success) {
                loginError.innerText = data.message || "Signup failed.";
                return;
            }

            loginError.innerText = "Account created! Check your email for OTP verification.";
            isSignupMode = false;
            loginTitle.innerText = "Sign in";
            loginBtn.innerText = "Login";
            switchMode.innerText = "Don't have an account? Sign up";
            loginPass2.style.display = "none";
            return;
        }

        // LOGIN
        const res = await fetch(API_BASE + "/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ email, password })
        });

        const data = await res.json();
        if (!data.success) {
            loginError.innerText = data.message || "Login failed.";
            return;
        }

        ACCESS_TOKEN = data.access_token;
        REFRESH_TOKEN = data.refresh_token;
        CURRENT_EMAIL = email;

         loginPopup.style.display = "none";
    whoEl.innerText = `Signed in as: ${CURRENT_EMAIL}`;
    messagesContainer.innerHTML = "";

    // Load summary & recent messages
    if (data.summary) addMessage(`**Summary of previous chats:**\n${data.summary}`, "aibot");
    if (data.recent_messages) addMessagesFromHistory(data.recent_messages);

    addMessage(`Welcome back, ${CURRENT_EMAIL}!`, "aibot");
    };

    async function refreshAccessToken() {
        if (!REFRESH_TOKEN) return false;

        try {
            const res = await fetch(API_BASE + "/auth/refresh", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ refresh_token: REFRESH_TOKEN })
            });
            if (!res.ok) return false;
            const data = await res.json();
            if (!data.access_token) return false;

            ACCESS_TOKEN = data.access_token;
            REFRESH_TOKEN = data.refresh_token;
            whoEl.innerText = `Signed in as: ${CURRENT_EMAIL}`;
            return true;
        } catch (e) {
            console.error("Refresh error:", e);
            return false;
        }
    }

    /* =================== CHATBOT =================== */
   
 async function sendMessage(text) {
        if (!ACCESS_TOKEN) return addMessage("Please login first.", "aibot");
        
        // 1. Add User Message
        addMessage(text, "user");
        
        // 2. Add Empty Bot Message (Placeholder)
        // We get the DOM element 'botBubble' back so we can fill it.
        const botBubble = addMessage("", "aibot");
        botBubble.innerHTML = '<span class="typing">Thinking...</span>'; // Temporary loading state

        try {
            const res = await fetch(API_BASE + "/chatbot", {
                method: "POST",
                headers: { 
                    "Content-Type": "application/json", 
                    "Authorization": "Bearer " + ACCESS_TOKEN 
                },
                body: JSON.stringify({ prompt: text })
            });

            if (res.status === 401) {
                const refreshed = await refreshAccessToken();
                if (refreshed) return sendMessage(text); // Retry
                botBubble.innerText = "Session expired. Please login.";
                loginPopup.style.display = "flex";
                return;
            }

            // 3. Initialize Stream Reader
            const reader = res.body.getReader();
            const decoder = new TextDecoder();
            let fullText = "";

            // 4. Read the Stream
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                // Decode the chunk (bytes -> string)
                const chunk = decoder.decode(value, { stream: true });
                fullText += chunk;

                // Update UI immediately
                // We re-parse Markdown on every chunk to ensure formatting (bold, code blocks) renders live.
                botBubble.innerHTML = marked.parse(fullText);
                
                // Auto-scroll to bottom
                messagesContainer.scrollTo({ top: messagesContainer.scrollHeight, behavior: "smooth" });
            }

        } catch (err) {
            console.error(err);
            botBubble.innerText = "Network error or connection lost.";
        }
    }

    messageForm.addEventListener("submit", e => {
        e.preventDefault();
        const text = messageInput.value.trim();
        if (!text) return;
        messageInput.value = "";
        sendMessage(text);
    });

    /* =================== FILE UPLOAD =================== */
    fileBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", async () => {
        if (!ACCESS_TOKEN) return addMessage("Please login to upload files.", "aibot");

        const file = fileInput.files[0];
        if (!file) return;
        const formData = new FormData();
        formData.append("file", file);

        addMessage(`Uploading ${file.name}...`, "user");
        showTyping();
        try {
            const res = await fetch(API_BASE + "/upload_document", {
                method: "POST",
                headers: { "Authorization": "Bearer " + ACCESS_TOKEN },
                body: formData
            });
            const data = await res.json();
            removeTyping();
            if (!res.ok) addMessage(data.detail || "Upload failed.", "aibot");
            else addMessage(`Uploaded **${file.name}**\nDocument ID: ${data.doc_id}\nChunks: ${data.num_chunks}`, "aibot");
        } catch (err) {
            removeTyping();
            addMessage("Upload error.", "aibot");
        }
        fileInput.value = "";
    });
//======================================================
  let mediaRecorder = null;
        let audioChunks = [];
        let recording = false;

        micBtn.addEventListener("click", async () => {
            if (!recording) {
                if (!navigator.mediaDevices?.getUserMedia) {
                    alert("Your browser does not support microphone recording.");
                    return;
                }
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
                audioChunks = [];
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
                    const formData = new FormData();
                    formData.append("file", audioBlob, "speech.webm");
                    try {
                        const res = await fetch(API_BASE + "/asr", { method: "POST", body: formData });
                        const data = await res.json();
                        const text = data.text;
                        messageInput.value = text;
                        await sendMessage(text);
                    } catch (err) {
                        console.error(err);
                        addMessage("Error during speech recognition.", "aibot");
                    }
                };
                mediaRecorder.start();
                recording = true;
                micBtn.innerText = "â¹ï¸";
            } else {
                recording = false;
                micBtn.innerText = "ðŸŽ¤";
                mediaRecorder.stop();
            }
        });

    /* =================== AUTO-REFRESH =================== */
    setInterval(() => { if (ACCESS_TOKEN) refreshAccessToken(); }, 10*60*1000);

    /* =================== AUTO LOGIN ON LOAD =================== */
    window.onload = async () => {
        const ok = await refreshAccessToken();
        if (ok) loginPopup.style.display = "none";
        else loginPopup.style.display = "flex";
    };
    </script>
</body>

</html>
